{"version":3,"file":"index.cjs.js","sources":["lib/get-custom-properties.js","lib/import-from.js","lib/conversions.js","lib/color.js","lib/manage-unresolved.js","lib/transform.js","index.js"],"sourcesContent":["import valueParser from 'postcss-values-parser';\n\n// return custom selectors from the css root, conditionally removing them\nexport default function getCustomProperties(root, opts) {\n\t// initialize custom selectors\n\tconst customPropertiesFromHtmlElement = {};\n\tconst customPropertiesFromRootPsuedo = {};\n\n\t// for each html or :root rule\n\troot.nodes.slice().forEach(rule => {\n\t\tconst customPropertiesObject = isHtmlRule(rule)\n\t\t\t? customPropertiesFromHtmlElement\n\t\t: isRootRule(rule)\n\t\t\t? customPropertiesFromRootPsuedo\n\t\t: null;\n\n\t\t// for each custom property\n\t\tif (customPropertiesObject) {\n\t\t\trule.nodes.slice().forEach(decl => {\n\t\t\t\tif (isCustomDecl(decl)) {\n\t\t\t\t\tconst { prop } = decl;\n\n\t\t\t\t\t// write the parsed value to the custom property\n\t\t\t\t\tcustomPropertiesObject[prop] = valueParser(decl.value).parse();\n\n\t\t\t\t\t// conditionally remove the custom property declaration\n\t\t\t\t\tif (!opts.preserve) {\n\t\t\t\t\t\tdecl.remove();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// conditionally remove the empty html or :root rule\n\t\t\tif (!opts.preserve && isEmptyParent(rule)) {\n\t\t\t\trule.remove();\n\t\t\t}\n\t\t}\n\t});\n\n\t// return all custom properties, preferring :root properties over html properties\n\treturn { ...customPropertiesFromHtmlElement, ...customPropertiesFromRootPsuedo };\n}\n\n// match html and :root rules\nconst htmlSelectorRegExp = /^html$/i;\nconst rootSelectorRegExp = /^:root$/i;\nconst customPropertyRegExp = /^--[A-z][\\w-]*$/;\n\n// whether the node is an html or :root rule\nconst isHtmlRule = node => node.type === 'rule' && htmlSelectorRegExp.test(node.selector) && Object(node.nodes).length;\nconst isRootRule = node => node.type === 'rule' && rootSelectorRegExp.test(node.selector) && Object(node.nodes).length;\n\n// whether the node is an custom property\nconst isCustomDecl = node => node.type === 'decl' && customPropertyRegExp.test(node.prop);\n\n// whether the node is a parent without children\nconst isEmptyParent = node => Object(node.nodes).length === 0;\n","import fs from 'fs';\nimport path from 'path';\nimport postcss from 'postcss';\nimport getCustomProperties from './get-custom-properties';\nimport valueParser from 'postcss-values-parser';\n\n/* Import Custom Properties from CSS AST\n/* ========================================================================== */\n\nfunction importCustomPropertiesFromCSSAST(root) {\n\treturn getCustomProperties(root, { preserve: true });\n}\n\n/* Import Custom Properties from CSS File\n/* ========================================================================== */\n\nasync function importCustomPropertiesFromCSSFile(from) {\n\tconst css = await readFile(from);\n\tconst root = postcss.parse(css, { from });\n\n\treturn importCustomPropertiesFromCSSAST(root);\n}\n\n/* Import Custom Properties from Object\n/* ========================================================================== */\n\nfunction importCustomPropertiesFromObject(object) {\n\tconst customProperties = Object.assign(\n\t\t{},\n\t\tObject(object).customProperties || Object(object)['custom-properties']\n\t);\n\n\tfor (const prop in customProperties) {\n\t\tcustomProperties[prop] = valueParser(customProperties[prop]).parse();\n\t}\n\n\treturn customProperties;\n}\n\n/* Import Custom Properties from JSON file\n/* ========================================================================== */\n\nasync function importCustomPropertiesFromJSONFile(from) {\n\tconst object = await readJSON(from);\n\n\treturn importCustomPropertiesFromObject(object);\n}\n\n/* Import Custom Properties from JS file\n/* ========================================================================== */\n\nasync function importCustomPropertiesFromJSFile(from) {\n\tconst object = await import(from);\n\n\treturn importCustomPropertiesFromObject(object);\n}\n\n/* Import Custom Properties from Sources\n/* ========================================================================== */\n\nexport default function importCustomPropertiesFromSources(sources) {\n\treturn sources.map(source => {\n\t\tif (source instanceof Promise) {\n\t\t\treturn source;\n\t\t} else if (source instanceof Function) {\n\t\t\treturn source();\n\t\t}\n\n\t\t// read the source as an object\n\t\tconst opts = source === Object(source) ? source : { from: String(source) };\n\n\t\t// skip objects with Custom Properties\n\t\tif (opts.customProperties || opts['custom-properties']) {\n\t\t\treturn opts\n\t\t}\n\n\t\t// source pathname\n\t\tconst from = path.resolve(String(opts.from || ''));\n\n\t\t// type of file being read from\n\t\tconst type = (opts.type || path.extname(from).slice(1)).toLowerCase();\n\n\t\treturn { type, from };\n\t}).reduce(async (customProperties, source) => {\n\t\tconst { type, from } = await source;\n\n\t\tif (type === 'ast') {\n\t\t\treturn Object.assign(await customProperties, importCustomPropertiesFromCSSAST(from));\n\t\t}\n\n\t\tif (type === 'css') {\n\t\t\treturn Object.assign(await customProperties, await importCustomPropertiesFromCSSFile(from));\n\t\t}\n\n\t\tif (type === 'js') {\n\t\t\treturn Object.assign(await customProperties, await importCustomPropertiesFromJSFile(from));\n\t\t}\n\n\t\tif (type === 'json') {\n\t\t\treturn Object.assign(await customProperties, await importCustomPropertiesFromJSONFile(from));\n\t\t}\n\n\t\treturn Object.assign(await customProperties, await importCustomPropertiesFromObject(await source));\n\t}, {});\n}\n\n/* Helper utilities\n/* ========================================================================== */\n\nconst readFile = from => new Promise((resolve, reject) => {\n\tfs.readFile(from, 'utf8', (error, result) => {\n\t\tif (error) {\n\t\t\treject(error);\n\t\t} else {\n\t\t\tresolve(result);\n\t\t}\n\t});\n});\n\nconst readJSON = async from => JSON.parse(await readFile(from));\n","/* Convert Degree to Hue Degree\n/* ========================================================================== */\n\nexport function convertDtoD(deg) {\n\treturn deg % 360;\n}\n\n/* Convert Gradian to Hue Degree\n/* ========================================================================== */\n\nexport function convertGtoD(grad) {\n\treturn grad * 0.9 % 360;\n}\n\n/* Convert Radian to Hue Degree\n/* ========================================================================== */\n\nexport function convertRtoD(rad) {\n\treturn rad * 180 / Math.PI % 360;\n}\n\n/* Convert Turn to Hue Degree\n/* ========================================================================== */\n\nexport function convertTtoD(turn) {\n\treturn turn * 360 % 360;\n}\n\n/* Convert a Name to Red/Green/Blue\n/* ========================================================================== */\n\nexport function convertNtoRGB(name) {\n\tconst names = {\n\t\taliceblue: [240, 248, 255],\n\t\tantiquewhite: [250, 235, 215],\n\t\taqua: [0, 255, 255],\n\t\taquamarine: [127, 255, 212],\n\t\tazure: [240, 255, 255],\n\t\tbeige: [245, 245, 220],\n\t\tbisque: [255, 228, 196],\n\t\tblack: [0, 0, 0],\n\t\tblanchedalmond: [255, 235, 205],\n\t\tblue: [0, 0, 255],\n\t\tblueviolet: [138, 43, 226],\n\t\tbrown: [165, 42, 42],\n\t\tburlywood: [222, 184, 135],\n\t\tcadetblue: [95, 158, 160],\n\t\tchartreuse: [127, 255, 0],\n\t\tchocolate: [210, 105, 30],\n\t\tcoral: [255, 127, 80],\n\t\tcornflowerblue: [100, 149, 237],\n\t\tcornsilk: [255, 248, 220],\n\t\tcrimson: [220, 20, 60],\n\t\tcyan: [0, 255, 255],\n\t\tdarkblue: [0, 0, 139],\n\t\tdarkcyan: [0, 139, 139],\n\t\tdarkgoldenrod: [184, 134, 11],\n\t\tdarkgray: [169, 169, 169],\n\t\tdarkgreen: [0, 100, 0],\n\t\tdarkgrey: [169, 169, 169],\n\t\tdarkkhaki: [189, 183, 107],\n\t\tdarkmagenta: [139, 0, 139],\n\t\tdarkolivegreen: [85, 107, 47],\n\t\tdarkorange: [255, 140, 0],\n\t\tdarkorchid: [153, 50, 204],\n\t\tdarkred: [139, 0, 0],\n\t\tdarksalmon: [233, 150, 122],\n\t\tdarkseagreen: [143, 188, 143],\n\t\tdarkslateblue: [72, 61, 139],\n\t\tdarkslategray: [47, 79, 79],\n\t\tdarkslategrey: [47, 79, 79],\n\t\tdarkturquoise: [0, 206, 209],\n\t\tdarkviolet: [148, 0, 211],\n\t\tdeeppink: [255, 20, 147],\n\t\tdeepskyblue: [0, 191, 255],\n\t\tdimgray: [105, 105, 105],\n\t\tdimgrey: [105, 105, 105],\n\t\tdodgerblue: [30, 144, 255],\n\t\tfirebrick: [178, 34, 34],\n\t\tfloralwhite: [255, 250, 240],\n\t\tforestgreen: [34, 139, 34],\n\t\tfuchsia: [255, 0, 255],\n\t\tgainsboro: [220, 220, 220],\n\t\tghostwhite: [248, 248, 255],\n\t\tgold: [255, 215, 0],\n\t\tgoldenrod: [218, 165, 32],\n\t\tgray: [128, 128, 128],\n\t\tgreen: [0, 128, 0],\n\t\tgreenyellow: [173, 255, 47],\n\t\tgrey: [128, 128, 128],\n\t\thoneydew: [240, 255, 240],\n\t\thotpink: [255, 105, 180],\n\t\tindianred: [205, 92, 92],\n\t\tindigo: [75, 0, 130],\n\t\tivory: [255, 255, 240],\n\t\tkhaki: [240, 230, 140],\n\t\tlavender: [230, 230, 250],\n\t\tlavenderblush: [255, 240, 245],\n\t\tlawngreen: [124, 252, 0],\n\t\tlemonchiffon: [255, 250, 205],\n\t\tlightblue: [173, 216, 230],\n\t\tlightcoral: [240, 128, 128],\n\t\tlightcyan: [224, 255, 255],\n\t\tlightgoldenrodyellow: [250, 250, 210],\n\t\tlightgray: [211, 211, 211],\n\t\tlightgreen: [144, 238, 144],\n\t\tlightgrey: [211, 211, 211],\n\t\tlightpink: [255, 182, 193],\n\t\tlightsalmon: [255, 160, 122],\n\t\tlightseagreen: [32, 178, 170],\n\t\tlightskyblue: [135, 206, 250],\n\t\tlightslategray: [119, 136, 153],\n\t\tlightslategrey: [119, 136, 153],\n\t\tlightsteelblue: [176, 196, 222],\n\t\tlightyellow: [255, 255, 224],\n\t\tlime: [0, 255, 0],\n\t\tlimegreen: [50, 205, 50],\n\t\tlinen: [250, 240, 230],\n\t\tmagenta: [255, 0, 255],\n\t\tmaroon: [128, 0, 0],\n\t\tmediumaquamarine: [102, 205, 170],\n\t\tmediumblue: [0, 0, 205],\n\t\tmediumorchid: [186, 85, 211],\n\t\tmediumpurple: [147, 112, 219],\n\t\tmediumseagreen: [60, 179, 113],\n\t\tmediumslateblue: [123, 104, 238],\n\t\tmediumspringgreen: [0, 250, 154],\n\t\tmediumturquoise: [72, 209, 204],\n\t\tmediumvioletred: [199, 21, 133],\n\t\tmidnightblue: [25, 25, 112],\n\t\tmintcream: [245, 255, 250],\n\t\tmistyrose: [255, 228, 225],\n\t\tmoccasin: [255, 228, 181],\n\t\tnavajowhite: [255, 222, 173],\n\t\tnavy: [0, 0, 128],\n\t\toldlace: [253, 245, 230],\n\t\tolive: [128, 128, 0],\n\t\tolivedrab: [107, 142, 35],\n\t\torange: [255, 165, 0],\n\t\torangered: [255, 69, 0],\n\t\torchid: [218, 112, 214],\n\t\tpalegoldenrod: [238, 232, 170],\n\t\tpalegreen: [152, 251, 152],\n\t\tpaleturquoise: [175, 238, 238],\n\t\tpalevioletred: [219, 112, 147],\n\t\tpapayawhip: [255, 239, 213],\n\t\tpeachpuff: [255, 218, 185],\n\t\tperu: [205, 133, 63],\n\t\tpink: [255, 192, 203],\n\t\tplum: [221, 160, 221],\n\t\tpowderblue: [176, 224, 230],\n\t\tpurple: [128, 0, 128],\n\t\trebeccapurple: [102, 51, 153],\n\t\tred: [255, 0, 0],\n\t\trosybrown: [188, 143, 143],\n\t\troyalblue: [65, 105, 225],\n\t\tsaddlebrown: [139, 69, 19],\n\t\tsalmon: [250, 128, 114],\n\t\tsandybrown: [244, 164, 96],\n\t\tseagreen: [46, 139, 87],\n\t\tseashell: [255, 245, 238],\n\t\tsienna: [160, 82, 45],\n\t\tsilver: [192, 192, 192],\n\t\tskyblue: [135, 206, 235],\n\t\tslateblue: [106, 90, 205],\n\t\tslategray: [112, 128, 144],\n\t\tslategrey: [112, 128, 144],\n\t\tsnow: [255, 250, 250],\n\t\tspringgreen: [0, 255, 127],\n\t\tsteelblue: [70, 130, 180],\n\t\ttan: [210, 180, 140],\n\t\tteal: [0, 128, 128],\n\t\tthistle: [216, 191, 216],\n\t\ttomato: [255, 99, 71],\n\t\ttransparent: [0, 0, 0],\n\t\tturquoise: [64, 224, 208],\n\t\tviolet: [238, 130, 238],\n\t\twheat: [245, 222, 179],\n\t\twhite: [255, 255, 255],\n\t\twhitesmoke: [245, 245, 245],\n\t\tyellow: [255, 255, 0],\n\t\tyellowgreen: [154, 205, 50]\n\t};\n\n\treturn names[name] && names[name].map(c => c / 2.55);\n}\n\n\n/* Convert a Hex to Red/Green/Blue\n/* ========================================================================== */\n\nexport function convertHtoRGB(hex) {\n\t// #<hex-color>{3,4,6,8}\n\tconst [r, g, b, a, rr, gg, bb, aa] = (hex.match(hexColorMatch) || []).slice(1);\n\n\tif (rr !== undefined || r !== undefined) {\n\t\tconst red   = rr !== undefined ? parseInt(rr, 16) : r !== undefined ? parseInt(r + r, 16) : 0;\n\t\tconst green = gg !== undefined ? parseInt(gg, 16) : g !== undefined ? parseInt(g + g, 16) : 0;\n\t\tconst blue  = bb !== undefined ? parseInt(bb, 16) : b !== undefined ? parseInt(b + b, 16) : 0;\n\t\tconst alpha = aa !== undefined ? parseInt(aa, 16) : a !== undefined ? parseInt(a + a, 16) : 255;\n\n\t\treturn [red, green, blue, alpha].map(c => c / 2.55);\n\t}\n\n\treturn undefined;\n}\n\nconst hexColorMatch = /^#(?:([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?|([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?)$/i;\n","import { rgb2hsl, rgb2hwb, hsl2rgb, hsl2hwb, hwb2rgb, hwb2hsl, rgb2hue } from '@csstools/convert-colors';\n\nexport default class Color {\n\tconstructor(color) {\n\t\tthis.color = Object(Object(color).color || color);\n\n\t\tthis.color.colorspace = this.color.colorspace\n\t\t\t? this.color.colorspace\n\t\t: 'red' in color && 'green' in color && 'blue' in color\n\t\t\t? 'rgb'\n\t\t: 'hue' in color && 'saturation' in color && 'lightness' in color\n\t\t\t? 'hsl'\n\t\t: 'hue' in color && 'whiteness' in color && 'blackness' in color\n\t\t\t? 'hwb'\n\t\t: 'unknown';\n\n\t\tif (color.colorspace === 'rgb') {\n\t\t\tthis.color.hue = rgb2hue(color.red, color.green, color.blue, color.hue || 0);\n\t\t}\n\t}\n\n\talpha(alpha) {\n\t\tconst color = this.color;\n\n\t\treturn alpha === undefined\n\t\t\t? color.alpha\n\t\t: new Color(assign(color, { alpha }));\n\t}\n\n\tblackness(blackness) {\n\t\tconst hwb = color2hwb(this.color);\n\n\t\treturn blackness === undefined\n\t\t\t? hwb.blackness\n\t\t: new Color(assign(hwb, { blackness }));\n\t}\n\n\tblend(color, percentage, colorspace = 'rgb') {\n\t\tconst base = this.color;\n\n\t\treturn new Color(blend(base, color, percentage, colorspace));\n\t}\n\n\tblenda(color, percentage, colorspace = 'rgb') {\n\t\tconst base = this.color;\n\n\t\treturn new Color(blend(base, color, percentage, colorspace, true));\n\t}\n\n\tblue(blue) {\n\t\tconst rgb = color2rgb(this.color);\n\n\t\treturn blue === undefined\n\t\t\t? rgb.blue\n\t\t: new Color(assign(rgb, { blue }));\n\t}\n\n\tcontrast(percentage) {\n\t\tconst base = this.color;\n\n\t\treturn new Color(contrast(base, percentage));\n\t}\n\n\tgreen(green) {\n\t\tconst rgb = color2rgb(this.color);\n\n\t\treturn green === undefined\n\t\t\t? rgb.green\n\t\t: new Color(assign(rgb, { green }));\n\t}\n\n\thue(hue) {\n\t\tconst hsl = color2hsl(this.color);\n\n\t\treturn hue === undefined\n\t\t\t? hsl.hue\n\t\t: new Color(assign(hsl, { hue }));\n\t}\n\n\tlightness(lightness) {\n\t\tconst hsl = color2hsl(this.color);\n\n\t\treturn lightness === undefined\n\t\t\t? hsl.lightness\n\t\t: new Color(assign(hsl, { lightness }))\n\t}\n\n\tred(red) {\n\t\tconst rgb = color2rgb(this.color);\n\n\t\treturn red === undefined\n\t\t\t? rgb.red\n\t\t: new Color(assign(rgb, { red }));\n\t}\n\n\trgb(red, green, blue) {\n\t\tconst rgb = color2rgb(this.color);\n\n\t\treturn new Color(assign(rgb, { red, green, blue }));\n\t}\n\n\tsaturation(saturation) {\n\t\tconst hsl = color2hsl(this.color);\n\n\t\treturn saturation === undefined\n\t\t\t? hsl.saturation\n\t\t: new Color(assign(hsl, { saturation }));\n\t}\n\n\tshade(percentage) {\n\t\tconst hwb = color2hwb(this.color);\n\t\tconst shade = { hue: 0, whiteness: 0, blackness: 100, colorspace: 'hwb' };\n\t\tconst colorspace = 'rgb';\n\n\t\treturn percentage === undefined\n\t\t\t? hwb.blackness\n\t\t: new Color(blend(hwb, shade, percentage, colorspace));\n\t}\n\n\ttint(percentage) {\n\t\tconst hwb = color2hwb(this.color);\n\t\tconst tint = { hue: 0, whiteness: 100, blackness: 0, colorspace: 'hwb' };\n\t\tconst colorspace = 'rgb';\n\n\t\treturn percentage === undefined\n\t\t\t? hwb.blackness\n\t\t: new Color(blend(hwb, tint, percentage, colorspace));\n\t}\n\n\twhiteness(whiteness) {\n\t\tconst hwb = color2hwb(this.color);\n\n\t\treturn whiteness === undefined\n\t\t\t? hwb.whiteness\n\t\t: new Color(assign(hwb, { whiteness }));\n\t}\n\n\ttoHSL() {\n\t\treturn color2hslString(this.color);\n\t}\n\n\ttoHWB() {\n\t\treturn color2hwbString(this.color);\n\t}\n\n\ttoLegacy() {\n\t\treturn color2legacyString(this.color);\n\t}\n\n\ttoRGB() {\n\t\treturn color2rgbString(this.color);\n\t}\n\n\ttoRGBLegacy() {\n\t\treturn color2rgbLegacyString(this.color);\n\t}\n\n\ttoString() {\n\t\treturn color2string(this.color);\n\t}\n}\n\n/* Blending\n/* ========================================================================== */\n\nfunction blend(base, color, percentage, colorspace, isBlendingAlpha) {\n\tconst addition    = percentage / 100;\n\tconst subtraction = 1 - addition;\n\n\tif (colorspace === 'hsl') {\n\t\tconst { hue: h1, saturation: s1, lightness: l1, alpha: a1 } = color2hsl(base);\n\t\tconst { hue: h2, saturation: s2, lightness: l2, alpha: a2 } = color2hsl(color);\n\n\t\tconst [hue, saturation, lightness, alpha] = [\n\t\t\th1 * subtraction + h2 * addition,\n\t\t\ts1 * subtraction + s2 * addition,\n\t\t\tl1 * subtraction + l2 * addition,\n\t\t\tisBlendingAlpha\n\t\t\t\t? a1 * subtraction + a2 * addition\n\t\t\t: a1\n\t\t];\n\n\t\treturn { hue, saturation, lightness, alpha, colorspace: 'hsl' };\n\t} else if (colorspace === 'hwb') {\n\t\tconst { hue: h1, whiteness: w1, blackness: b1, alpha: a1 } = color2hwb(base);\n\t\tconst { hue: h2, whiteness: w2, blackness: b2, alpha: a2 } = color2hwb(color);\n\n\t\tconst [hue, whiteness, blackness, alpha] = [\n\t\t\th1 * subtraction + h2 * addition,\n\t\t\tw1 * subtraction + w2 * addition,\n\t\t\tb1 * subtraction + b2 * addition,\n\t\t\tisBlendingAlpha\n\t\t\t\t? a1 * subtraction + a2 * addition\n\t\t\t: a1\n\t\t];\n\n\t\treturn { hue, whiteness, blackness, alpha, colorspace: 'hwb' };\n\t} else {\n\t\tconst { red: r1, green: g1, blue: b1, alpha: a1 } = color2rgb(base);\n\t\tconst { red: r2, green: g2, blue: b2, alpha: a2 } = color2rgb(color);\n\n\t\tconst [red, green, blue, alpha] = [\n\t\t\tr1 * subtraction + r2 * addition,\n\t\t\tg1 * subtraction + g2 * addition,\n\t\t\tb1 * subtraction + b2 * addition,\n\t\t\tisBlendingAlpha\n\t\t\t\t? a1 * subtraction + a2 * addition\n\t\t\t: a1\n\t\t];\n\n\t\treturn { red, green, blue, alpha, colorspace: 'rgb' };\n\t}\n}\n\n/* Assign channels to a new instance of a base color\n/* ========================================================================== */\n\nfunction assign(base, channels) {\n\tconst color = Object.assign({}, base);\n\n\tObject.keys(channels).forEach(\n\t\tchannel => {\n\t\t\t// detect channel\n\t\t\tconst isHue = channel === 'hue';\n\t\t\tconst isRGB = !isHue && blueGreenRedMatch.test(channel);\n\n\t\t\t// normalized value of the channel\n\t\t\tconst value = normalize(channels[channel], channel);\n\n\t\t\t// assign channel to new object\n\t\t\tcolor[channel] = value;\n\n\t\t\tif (isRGB) {\n\t\t\t\t// conditionally preserve the hue\n\t\t\t\tcolor.hue = rgb2hue(color.red, color.green, color.blue, base.hue || 0);\n\t\t\t}\n\t\t}\n\t);\n\n\treturn color;\n}\n\nfunction normalize(value, channel) {\n\t// detect channel\n\tconst isHue = channel === 'hue';\n\n\t// value limitations\n\tconst min = 0;\n\tconst max = isHue ? 360 : 100;\n\n\tconst normalizedValue = Math.min(Math.max(isHue\n\t\t? value % 360\n\t: value, min), max);\n\n\treturn normalizedValue;\n}\n\n/* Convert colors\n/* ========================================================================== */\n\nfunction color2rgb(color) {\n\tconst [ red, green, blue ] = color.colorspace === 'hsl'\n\t\t? hsl2rgb(color.hue, color.saturation, color.lightness)\n\t: color.colorspace === 'hwb'\n\t\t? hwb2rgb(color.hue, color.whiteness, color.blackness)\n\t: [ color.red, color.green, color.blue ];\n\n\treturn { red, green, blue, hue: color.hue, alpha: color.alpha, colorspace: 'rgb' };\n}\n\nfunction color2hsl(color) {\n\tconst [ hue, saturation, lightness ] = color.colorspace === 'rgb'\n\t\t? rgb2hsl(color.red, color.green, color.blue, color.hue)\n\t: color.colorspace === 'hwb'\n\t\t? hwb2hsl(color.hue, color.whiteness, color.blackness)\n\t: [ color.hue, color.saturation, color.lightness ];\n\n\treturn { hue, saturation, lightness, alpha: color.alpha, colorspace: 'hsl' };\n}\n\nfunction color2hwb(color) {\n\tconst [ hue, whiteness, blackness ] = color.colorspace === 'rgb'\n\t\t? rgb2hwb(color.red, color.green, color.blue, color.hue)\n\t: color.colorspace === 'hsl'\n\t\t? hsl2hwb(color.hue, color.saturation, color.lightness)\n\t: [ color.hue, color.whiteness, color.blackness ];\n\n\treturn { hue, whiteness, blackness, alpha: color.alpha, colorspace: 'hwb' };\n}\n\n/* Contrast functions\n/* ========================================================================== */\n\nfunction contrast(color, percentage) {\n\t// https://drafts.csswg.org/css-color/#contrast-adjuster\n\tconst hwb = color2hwb(color);\n\tconst rgb = color2rgb(color);\n\n\t// compute the luminance of the color.\n\tconst luminance = rgb2luminance(rgb.red, rgb.green, rgb.blue);\n\n\t// the maximum-contrast color, if it is less than .5\n\tconst maxContrastColor = luminance < 0.5\n\t\t// hwb(X, 100%, 0%), where X is the hue angle of the color\n\t\t? { hue: hwb.hue, whiteness: 100, blackness: 0, alpha: hwb.alpha, colorspace: 'hwb' }\n\t// otherwise, hwb(X, 0%, 100%), where X is the hue angle of the color\n\t: { hue: hwb.hue, whiteness: 0, blackness: 100, alpha: hwb.alpha, colorspace: 'hwb' };\n\n\t// contrast ratio\n\tconst contrastRatio = colors2contrast(color, maxContrastColor);\n\n\tconst minContrastColor = contrastRatio > 4.5\n\t\t// the color with the smallest contrast ratio with the base color that is greater than 4.5\n\t\t? colors2contrastRatioColor(hwb, maxContrastColor)\n\t// otherwise, the maximum-contrast color\n\t: maxContrastColor;\n\n\t// color(maximum-contrast blend(minimum-contrast <percentage> hwb)));\n\treturn blend(maxContrastColor, minContrastColor, percentage, 'hwb', false);\n}\n\nfunction colors2contrast(color1, color2) {\n\t// https://drafts.csswg.org/css-color/#contrast-ratio\n\tconst rgb1 = color2rgb(color1);\n\tconst rgb2 = color2rgb(color2);\n\tconst l1 = rgb2luminance(rgb1.red, rgb1.green, rgb1.blue);\n\tconst l2 = rgb2luminance(rgb2.red, rgb2.green, rgb2.blue);\n\n\treturn l1 > l2\n\t\t// if l1 is the relative luminance of the lighter of the colors\n\t\t? (l1 + 0.05) / (l2 + 0.05)\n\t// otherwise, if l2 is the relative luminance of the lighter of the colors\n\t: (l2 + 0.05) / (l1 + 0.05);\n}\n\nfunction rgb2luminance(red, green, blue) {\n\tconst [ redLuminance, greenLuminance, blueLuminance ] = [\n\t\tchannel2luminance(red),\n\t\tchannel2luminance(green),\n\t\tchannel2luminance(blue)\n\t];\n\n\t// https://drafts.csswg.org/css-color/#luminance\n\tconst luminance = 0.2126 * redLuminance + 0.7152 * greenLuminance + 0.0722 * blueLuminance;\n\n\treturn luminance;\n}\n\nfunction channel2luminance(value) {\n\t// https://drafts.csswg.org/css-color/#luminance\n\tconst luminance = value <= 0.03928 ? value / 12.92 : Math.pow((value + 0.055) /1.055, 2.4);\n\n\treturn luminance;\n}\n\n// return the smallest contrast ratio from a color and a maximum contrast (credit: @thetalecrafter)\nfunction colors2contrastRatioColor(hwb, maxHWB) {\n\tconst modifiedHWB = Object.assign({}, hwb);\n\n\t// values to be used for linear interpolations in HWB space\n\tlet minW = hwb.whiteness;\n\tlet minB = hwb.blackness;\n\tlet maxW = maxHWB.whiteness;\n\tlet maxB = maxHWB.blackness;\n\n\t// find the color with the smallest contrast ratio with the base color that is greater than 4.5\n\twhile (Math.abs(minW - maxW) > 100 || Math.abs(minB - maxB) > 100) {\n\t\tconst midW = Math.round((maxW + minW) / 2);\n\t\tconst midB = Math.round((maxB + minB) / 2);\n\n\t\tmodifiedHWB.whiteness = midW;\n\t\tmodifiedHWB.blackness = midB;\n\n\t\tif (colors2contrast(modifiedHWB, hwb) > 4.5) {\n\t\t\tmaxW = midW;\n\t\t\tmaxB = midB;\n\t\t} else {\n\t\t\tminW = midW;\n\t\t\tminB = midB;\n\t\t}\n\t}\n\n\treturn modifiedHWB;\n}\n\n/* Match\n/* ========================================================================== */\n\nconst blueGreenRedMatch = /^(blue|green|red)$/i;\n\n/* Stringifiers\n/* ========================================================================== */\n\nfunction color2string(color) {\n\treturn color.colorspace === 'hsl'\n\t\t? color2hslString(color)\n\t: color.colorspace === 'hwb'\n\t\t? color2hwbString(color)\n\t: color2rgbString(color);\n}\n\nfunction color2hslString(color) {\n\tconst hsl        = color2hsl(color);\n\tconst isOpaque   = hsl.alpha === 100;\n\tconst hue        = hsl.hue;\n\tconst saturation = Math.round(hsl.saturation * 10000000000) / 10000000000;\n\tconst lightness  = Math.round(hsl.lightness * 10000000000) / 10000000000;\n\tconst alpha      = Math.round(hsl.alpha * 10000000000) / 10000000000;\n\n\treturn `hsl(${hue} ${saturation}% ${lightness}%${isOpaque\n\t\t? ''\n\t: ` / ${alpha}%`})`;\n}\n\nfunction color2hwbString(color) {\n\tconst hwb       = color2hwb(color);\n\tconst isOpaque  = hwb.alpha === 100;\n\tconst hue       = hwb.hue;\n\tconst whiteness = Math.round(hwb.whiteness * 10000000000) / 10000000000;\n\tconst blackness = Math.round(hwb.blackness * 10000000000) / 10000000000;\n\tconst alpha     = Math.round(hwb.alpha * 10000000000) / 10000000000;\n\n\treturn `hwb(${hue} ${whiteness}% ${blackness}%${isOpaque\n\t\t? ''\n\t: ` / ${alpha}%`})`;\n}\n\nfunction color2rgbString(color) {\n\tconst rgb      = color2rgb(color);\n\tconst isOpaque = rgb.alpha === 100;\n\tconst red      = Math.round(rgb.red * 10000000000) / 10000000000;\n\tconst green    = Math.round(rgb.green * 10000000000) / 10000000000;\n\tconst blue     = Math.round(rgb.blue * 10000000000) / 10000000000;\n\tconst alpha    = Math.round(rgb.alpha * 10000000000) / 10000000000;\n\n\treturn `rgb(${red}% ${green}% ${blue}%${isOpaque\n\t\t? ''\n\t: ` / ${alpha}%`})`;\n}\n\nfunction color2legacyString(color) {\n\treturn color.colorspace === 'hsl'\n\t\t? color2hslLegacyString(color)\n\t: color2rgbLegacyString(color);\n}\n\nfunction color2rgbLegacyString(color) {\n\tconst rgb      = color2rgb(color);\n\tconst isOpaque = rgb.alpha === 100;\n\tconst name     = isOpaque ? 'rgb' : 'rgba';\n\tconst red      = Math.round(rgb.red * 255 / 100);\n\tconst green    = Math.round(rgb.green * 255 / 100);\n\tconst blue     = Math.round(rgb.blue * 255 / 100);\n\tconst alpha    = Math.round(rgb.alpha / 100 * 10000000000) / 10000000000;\n\n\treturn `${name}(${red}, ${green}, ${blue}${isOpaque\n\t\t? ''\n\t: `, ${alpha}`})`;\n}\n\nfunction color2hslLegacyString(color) {\n\tconst hsl        = color2hsl(color);\n\tconst isOpaque   = hsl.alpha === 100;\n\tconst name       = isOpaque ? 'hsl' : 'hsla';\n\tconst hue        = hsl.hue;\n\tconst saturation = Math.round(hsl.saturation * 10000000000) / 10000000000;\n\tconst lightness  = Math.round(hsl.lightness * 10000000000) / 10000000000;\n\tconst alpha      = Math.round(hsl.alpha / 100 * 10000000000) / 10000000000;\n\n\treturn `${name}(${hue}, ${saturation}%, ${lightness}%${isOpaque\n\t\t? ''\n\t: `, ${alpha}`})`;\n}\n","export default function manageUnresolved(node, opts, word, message) {\n\tif ('warn' === opts.unresolved) {\n\t\topts.decl.warn(opts.result, message, { word });\n\t} else if ('ignore' !== opts.unresolved) {\n\t\tthrow opts.decl.error(message, { word });\n\t}\n}\n","// tooling\nimport { convertDtoD, convertGtoD, convertRtoD, convertTtoD, convertNtoRGB, convertHtoRGB } from './conversions';\nimport Color from './color';\nimport manageUnresolved from './manage-unresolved';\nimport parser from 'postcss-values-parser';\n\n/* Transform AST\n/* ========================================================================== */\n\nexport default function transformAST(node, opts) {\n\tnode.nodes.slice(0).forEach(child => {\n\t\tif (isColorModFunction(child)) {\n\t\t\t// transform any variables within the color-mod() function\n\t\t\tif (opts.transformVars) {\n\t\t\t\ttransformVariables(child, opts);\n\t\t\t}\n\n\t\t\t// transform any color-mod() functions\n\t\t\tconst color = transformColorModFunction(child, opts);\n\n\t\t\tif (color) {\n\t\t\t\t// update the color-mod() function with the transformed value\n\t\t\t\tchild.replaceWith(parser.word({\n\t\t\t\t\traws: child.raws,\n\t\t\t\t\tvalue: opts.stringifier(color)\n\t\t\t\t}));\n\t\t\t}\n\t\t} else if (child.nodes && Object(child.nodes).length) {\n\t\t\ttransformAST(child, opts);\n\t\t}\n\t});\n}\n\n/* Transform <var> functions\n/* ========================================================================== */\n\nfunction transformVariables(node, opts) {\n\twalk(node, child => {\n\t\tif (isVariable(child)) {\n\t\t\t// get the custom property and fallback value from var()\n\t\t\tconst [prop, fallbackNode] = transformArgsByParams(child, [\n\t\t\t\t// <value> , [ <fallback> ]?\n\t\t\t\t[transformWord, isComma, transformNode]\n\t\t\t]);\n\n\t\t\t// if the custom property is known\n\t\t\tif (prop in opts.customProperties) {\n\t\t\t\tlet customPropertyValue = opts.customProperties[prop];\n\n\t\t\t\t// follow custom properties referencing custom properties\n\t\t\t\tif (looseVarMatch.test(customPropertyValue)) {\n\t\t\t\t\tconst rootChildAST = customPropertyValue.clone();\n\n\t\t\t\t\ttransformVariables(rootChildAST, opts);\n\n\t\t\t\t\tcustomPropertyValue = rootChildAST;\n\t\t\t\t}\n\n\t\t\t\t// replace var() with the custom property value\n\t\t\t\tif (customPropertyValue.nodes.length === 1 && customPropertyValue.nodes[0].nodes.length) {\n\t\t\t\t\tcustomPropertyValue.nodes[0].nodes.forEach(customPropertyChild => {\n\t\t\t\t\t\tchild.parent.insertBefore(child, customPropertyChild);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tchild.remove();\n\t\t\t} else if (fallbackNode && fallbackNode.nodes.length === 1 && fallbackNode.nodes[0].nodes.length) {\n\t\t\t\t// otherwise, replace var() with the fallback value\n\t\t\t\ttransformVariables(fallbackNode, opts);\n\n\t\t\t\tchild.replaceWith(...fallbackNode.nodes[0].nodes[0]);\n\t\t\t}\n\t\t}\n\t});\n}\n\n/* Transform <color> functions\n/* ========================================================================== */\n\nfunction transformColor(node, opts) {\n\tif (isRGBFunction(node)) {\n\t\treturn transformRGBFunction(node, opts);\n\t} else if (isHSLFunction(node)) {\n\t\treturn transformHSLFunction(node, opts);\n\t} else if (isHWBFunction(node)) {\n\t\treturn transformHWBFunction(node, opts);\n\t} else if (isColorModFunction(node)) {\n\t\treturn transformColorModFunction(node, opts);\n\t} else if (isHexColor(node)) {\n\t\treturn transformHexColor(node, opts);\n\t} else if (isNamedColor(node)) {\n\t\treturn transformNamedColor(node, opts);\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a color`);\n\t}\n}\n\n// return a transformed rgb/rgba color function\nfunction transformRGBFunction(node, opts) {\n\tconst [red, green, blue, alpha = 100] = transformArgsByParams(node, [\n\t\t// <percentage> <percentage> <percentage> [ , <alpha-value> ]?\n\t\t[transformPercentage, transformPercentage, transformPercentage, isSlash, transformAlpha],\n\t\t// <number> <number> <number> [ , <alpha-value> ]?\n\t\t[transformRGBNumber, transformRGBNumber, transformRGBNumber, isSlash, transformAlpha],\n\t\t// <percentage> , <percentage> , <percentage> [ , <alpha-value> ]?\n\t\t[transformPercentage, isComma, transformPercentage, isComma, transformPercentage, isComma, transformAlpha],\n\t\t// <number> , <number> , <number> [ , <alpha-value> ]?\n\t\t[transformRGBNumber, isComma, transformRGBNumber, isComma, transformRGBNumber, isComma, transformAlpha]\n\t]);\n\n\tif (red !== undefined) {\n\t\tconst color = new Color({ red, green, blue, alpha, colorspace: 'rgb' });\n\n\t\treturn color;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid rgb() function`);\n\t}\n}\n\n// return a transformed hsl/hsla color function\nfunction transformHSLFunction(node, opts) {\n\tconst [hue, saturation, lightness, alpha = 100] = transformArgsByParams(node, [\n\t\t// <hue> <percentage> <percentage> [ / <alpha-value> ]?\n\t\t[transformHue, transformPercentage, transformPercentage, isSlash, transformAlpha],\n\t\t// <hue> , <percentage> , <percentage> [ , <alpha-value> ]?\n\t\t[transformHue, isComma, transformPercentage, isComma, transformPercentage, isComma, transformAlpha]\n\t]);\n\n\tif (lightness !== undefined) {\n\t\tconst color = new Color({ hue, saturation, lightness, alpha, colorspace: 'hsl' });\n\n\t\treturn color;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid hsl() function`);\n\t}\n}\n\n// return a transformed hwb color function\nfunction transformHWBFunction(node, opts) {\n\tconst [hue, whiteness, blackness, alpha = 100] = transformArgsByParams(node, [\n\t\t// <hue> <percentage> <percentage> [ / <alpha-value> ]?\n\t\t[transformHue, transformPercentage, transformPercentage, isSlash, transformAlpha]\n\t]);\n\n\tif (blackness !== undefined) {\n\t\tconst color = new Color({ hue, whiteness, blackness, alpha, colorspace: 'hwb' });\n\n\t\treturn color;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid hwb() function`);\n\t}\n}\n\n// return a transformed color-mod color function\nfunction transformColorModFunction(node, opts) {\n\t// [ <color> | <hue> ] <color-adjuster>*\n\tconst [colorOrHueNode, ...adjusterNodes] = (node.nodes || []).slice(1, -1) || [];\n\n\tif (colorOrHueNode !== undefined) {\n\t\tconst color = isHue(colorOrHueNode)\n\t\t\t? new Color({\n\t\t\t\thue: transformHue(colorOrHueNode, opts),\n\t\t\t\tsaturation: 100,\n\t\t\t\tlightness: 50,\n\t\t\t\talpha: 100,\n\t\t\t\tcolorspace: 'hsl'\n\t\t\t})\n\t\t: transformColor(colorOrHueNode, opts);\n\n\t\tif (color) {\n\t\t\tconst adjustedColor = transformColorByAdjusters(color, adjusterNodes, opts);\n\n\t\t\treturn adjustedColor;\n\t\t} else {\n\t\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid color`);\n\t\t}\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid color-mod() function`);\n\t}\n}\n\n// return a transformed hex color\nfunction transformHexColor(node, opts) {\n\tif (hexColorMatch.test(node.value)) {\n\t\t// #<hex-color>{3,4,6,8}\n\t\tconst [red, green, blue, alpha] = convertHtoRGB(node.value);\n\n\t\tconst color = new Color({ red, green, blue, alpha });\n\n\t\treturn color;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid hex color`);\n\t}\n}\n\n// return a transformed named-color\nfunction transformNamedColor(node, opts) {\n\tif (isNamedColor(node)) {\n\t\t// <named-color>\n\t\tconst [red, green, blue] = convertNtoRGB(node.value);\n\n\t\tconst color = new Color({ red, green, blue, alpha: 100, colorspace: 'rgb' });\n\n\t\treturn color;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid named-color`);\n\t}\n}\n\n/* Transform <color-adjuster> functions\n/* ========================================================================== */\n\n// return a transformed color using adjustments\nfunction transformColorByAdjusters(color, adjusterNodes, opts) {\n\tconst adjustedColor = adjusterNodes.reduce((base, node) => {\n\t\tif (isAlphaBlueGreenRedAdjuster(node)) {\n\t\t\treturn transformAlphaBlueGreenRedAdjuster(base, node, opts);\n\t\t} else if (isRGBAdjuster(node)) {\n\t\t\treturn transformRGBAdjuster(base, node, opts);\n\t\t} else if (isHueAdjuster(node)) {\n\t\t\treturn transformHueAdjuster(base, node, opts);\n\t\t} else if (isBlacknessLightnessSaturationWhitenessAdjuster(node)) {\n\t\t\treturn transformBlacknessLightnessSaturationWhitenessAdjuster(base, node, opts);\n\t\t} else if (isShadeTintAdjuster(node)) {\n\t\t\treturn transformShadeTintAdjuster(base, node, opts);\n\t\t} else if (isBlendAdjuster(node)) {\n\t\t\treturn transformBlendAdjuster(base, node, node.value === 'blenda', opts);\n\t\t} else if (isContrastAdjuster(node)) {\n\t\t\treturn transformContrastAdjuster(base, node, opts);\n\t\t} else {\n\t\t\tmanageUnresolved(node, opts, node.value, `Expected a valid color adjuster`);\n\n\t\t\treturn base;\n\t\t}\n\t}, color);\n\n\treturn adjustedColor;\n}\n\n// return a transformed color using a/alpha/blue/green/red adjustments\nfunction transformAlphaBlueGreenRedAdjuster(base, node, opts) {\n\tconst [operatorOrValue, adjustment] = transformArgsByParams(node, alphaMatch.test(node.value)\n\t\t\t// a/alpha adjustments\n\t\t\t? [\n\t\t\t\t// [ + | - ] <alpha-value>\n\t\t\t\t[transformMinusPlusOperator, transformAlpha],\n\t\t\t\t// * <percentage>\n\t\t\t\t[transformTimesOperator, transformPercentage],\n\t\t\t\t// <alpha-value>\n\t\t\t\t[transformAlpha]\n\t\t\t]\n\t\t// blue/green/red adjustments\n\t\t: [\n\t\t\t// [ + | - ] <percentage>\n\t\t\t[transformMinusPlusOperator, transformPercentage],\n\t\t\t// [ + | - ] <number>\n\t\t\t[transformMinusPlusOperator, transformRGBNumber],\n\t\t\t// * <percentage>\n\t\t\t[transformTimesOperator, transformPercentage],\n\t\t\t// <percentage>\n\t\t\t[transformPercentage],\n\t\t\t// <number>\n\t\t\t[transformRGBNumber]\n\t\t]\n\t);\n\n\tif (operatorOrValue !== undefined) {\n\t\t// normalized channel name\n\t\tconst channel = node.value.toLowerCase().replace(alphaMatch, 'alpha');\n\n\t\tconst existingValue = base[channel]();\n\n\t\tconst modifiedValue = adjustment !== undefined\n\t\t\t? operatorOrValue === '+'\n\t\t\t\t? existingValue + Number(adjustment)\n\t\t\t: operatorOrValue === '-'\n\t\t\t\t? existingValue - Number(adjustment)\n\t\t\t: operatorOrValue === '*'\n\t\t\t\t? existingValue * Number(adjustment)\n\t\t\t: Number(adjustment)\n\t\t: Number(operatorOrValue);\n\n\t\tconst modifiedColor = base[channel](modifiedValue);\n\n\t\treturn modifiedColor;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid modifier()`);\n\t}\n}\n\n// return a transformed color using an rgb adjustment\nfunction transformRGBAdjuster(base, node, opts) {\n\tconst [arg1, arg2, arg3, arg4] = transformArgsByParams(node, [\n\t\t\t// [ + | - ] <percentage> <percentage> <percentage>\n\t\t\t[transformMinusPlusOperator, transformPercentage, transformPercentage, transformPercentage],\n\t\t\t// [ + | - ] <number> <number> <number>\n\t\t\t[transformMinusPlusOperator, transformRGBNumber, transformRGBNumber, transformRGBNumber],\n\t\t\t// [ + | - ] <hash-token>\n\t\t\t[transformMinusPlusOperator, transformHexColor],\n\t\t\t// [ * ] <percentage>\n\t\t\t[transformTimesOperator, transformPercentage]\n\t\t]\n\t);\n\n\tif (arg2 !== undefined && arg2.color) {\n\t\tconst modifiedColor = base.rgb(\n\t\t\targ1 === '+'\n\t\t\t\t? base.red() + arg2.red()\n\t\t\t: base.red() - arg2.red(),\n\t\t\targ1 === '+'\n\t\t\t\t? base.green() + arg2.green()\n\t\t\t: base.green() - arg2.green(),\n\t\t\targ1 === '+'\n\t\t\t\t? base.blue() + arg2.blue()\n\t\t\t: base.blue() - arg2.blue()\n\t\t);\n\n\t\treturn modifiedColor;\n\t} else if (arg1 !== undefined && minusPlusMatch.test(arg1)) {\n\t\tconst modifiedColor = base.rgb(\n\t\t\targ1 === '+'\n\t\t\t\t? base.red() + arg2\n\t\t\t: base.red() - arg2,\n\t\t\targ1 === '+'\n\t\t\t\t? base.green() + arg3\n\t\t\t: base.green() - arg3,\n\t\t\targ1 === '+'\n\t\t\t\t? base.blue() + arg4\n\t\t\t: base.blue() - arg4\n\t\t);\n\n\t\treturn modifiedColor;\n\t} else if (arg1 !== undefined && arg2 !== undefined) {\n\t\tconst modifiedColor = base.rgb(\n\t\t\tbase.red() * arg2,\n\t\t\tbase.green() * arg2,\n\t\t\tbase.blue() * arg2\n\t\t);\n\n\t\treturn modifiedColor;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid rgb() adjuster`);\n\t}\n}\n\n// return a transformed color using a blend/blenda adjustment\nfunction transformBlendAdjuster(base, node, isAlphaBlend, opts) {\n\tconst [color, percentage, colorspace = 'rgb'] = transformArgsByParams(node, [\n\t\t[transformColor, transformPercentage, transformColorSpace]\n\t]);\n\n\tif (percentage !== undefined) {\n\t\tconst modifiedColor = isAlphaBlend\n\t\t\t? base.blenda(color.color, percentage, colorspace)\n\t\t: base.blend(color.color, percentage, colorspace);\n\n\t\treturn modifiedColor;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid blend() adjuster)`);\n\t}\n}\n\n// return a transformed color using a contrast adjustment\nfunction transformContrastAdjuster(base, node, opts) {\n\tconst [percentage] = transformArgsByParams(node, [\n\t\t// <percentage>\n\t\t[transformPercentage]\n\t]);\n\n\tif (percentage !== undefined) {\n\t\tconst modifiedColor = base.contrast(percentage);\n\n\t\treturn modifiedColor;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid contrast() adjuster)`);\n\t}\n}\n\n// return a transformed color using a hue adjustment\nfunction transformHueAdjuster(base, node, opts) {\n\tconst [operatorOrHue, adjustment] = transformArgsByParams(node, [\n\t\t// [ + | - | * ] <angle>\n\t\t[transformMinusPlusTimesOperator, transformHue],\n\t\t// <angle>\n\t\t[transformHue]\n\t]);\n\n\tif (operatorOrHue !== undefined) {\n\t\tconst existingHue = base.hue();\n\n\t\tconst modifiedValue = adjustment !== undefined\n\t\t\t? operatorOrHue === '+'\n\t\t\t\t? existingHue + Number(adjustment)\n\t\t\t: operatorOrHue === '-'\n\t\t\t\t? existingHue - Number(adjustment)\n\t\t\t: operatorOrHue === '*'\n\t\t\t\t? existingHue * Number(adjustment)\n\t\t\t: Number(adjustment)\n\t\t: Number(operatorOrHue);\n\n\t\treturn base.hue(modifiedValue);\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid hue() function)`);\n\t}\n}\n\n// [ b | blackness | l | lightness | s | saturation | w | whiteness ]( [ + | - | * ]? <percentage> )\nfunction transformBlacknessLightnessSaturationWhitenessAdjuster(base, node, opts) {\n\tconst channel = node.value.toLowerCase().replace(/^b$/, 'blackness').replace(/^l$/, 'lightness').replace(/^s$/, 'saturation').replace(/^w$/, 'whiteness');\n\tconst [operatorOrValue, adjustment] = transformArgsByParams(node, [\n\t\t[transformMinusPlusTimesOperator, transformPercentage],\n\t\t[transformPercentage]\n\t]);\n\n\tif (operatorOrValue !== undefined) {\n\t\tconst existingValue = base[channel]();\n\n\t\tconst modifiedValue = adjustment !== undefined\n\t\t\t? operatorOrValue === '+'\n\t\t\t\t? existingValue + Number(adjustment)\n\t\t\t: operatorOrValue === '-'\n\t\t\t\t? existingValue - Number(adjustment)\n\t\t\t: operatorOrValue === '*'\n\t\t\t\t? existingValue * Number(adjustment)\n\t\t\t: Number(adjustment)\n\t\t: Number(operatorOrValue);\n\n\t\treturn base[channel](modifiedValue);\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid ${channel}() function)`);\n\t}\n}\n\n// return a transformed color using shade/tint adjustments\nfunction transformShadeTintAdjuster(base, node, opts) {\n\tconst channel = node.value.toLowerCase();\n\tconst [percentage] = transformArgsByParams(node, [\n\t\t// [ shade | tint ]( <percentage> )\n\t\t[transformPercentage]\n\t]);\n\n\tif (percentage !== undefined) {\n\t\tconst modifiedValue = Number(percentage);\n\n\t\treturn base[channel](modifiedValue);\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected valid ${channel}() arguments`);\n\t}\n}\n\n/* Argument Transforms\n/* ========================================================================== */\n\n// return a transformed color space\nfunction transformColorSpace(node, opts) {\n\tif (isColorSpace(node)) {\n\t\t// [ hsl | hwb | rgb ]\n\t\treturn node.value;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid color space)`);\n\t}\n}\n\n// return a transformed alpha value\nfunction transformAlpha(node, opts) {\n\tif (isNumber(node)) {\n\t\t// <number>\n\t\treturn node.value * 100;\n\t} else if (isPercentage(node)) {\n\t\t// <percentage>\n\t\treturn transformPercentage(node, opts);\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid alpha value)`);\n\t}\n}\n\n// return a transformed rgb number\nfunction transformRGBNumber(node, opts) {\n\tif (isNumber(node)) {\n\t\t// <number>\n\t\treturn node.value / 2.55;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid RGB value)`);\n\t}\n}\n\n// return a transformed hue\nfunction transformHue(node, opts) {\n\tif (isHue(node)) {\n\t\t// <hue> = <number> | <angle>\n\t\tconst unit = node.unit.toLowerCase();\n\n\t\tif (unit === 'grad') {\n\t\t\t// if <angle> = <gradian> (400 per circle)\n\t\t\treturn convertGtoD(node.value);\n\t\t} else if (unit === 'rad') {\n\t\t\t// if <angle> = <radian> (2Ï€ per circle)\n\t\t\treturn convertRtoD(node.value);\n\t\t} else if (unit === 'turn') {\n\t\t\t// if <angle> = <turn> (1 per circle)\n\t\t\treturn convertTtoD(node.value);\n\t\t} else {\n\t\t\t// if <angle> = [ <degree> | <number> ] (360 per circle)\n\t\t\treturn convertDtoD(node.value);\n\t\t}\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid hue`);\n\t}\n}\n\n// return a transformed percentage\nfunction transformPercentage(node, opts) {\n\tif (isPercentage(node)) {\n\t\t// <percentage>\n\t\treturn Number(node.value);\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid hue`);\n\t}\n}\n\n// return a transformed minus-plus operator\nfunction transformMinusPlusOperator(node, opts) {\n\tif (isMinusPlusOperator(node)) {\n\t\t// [ - | + ]\n\t\treturn node.value;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a plus or minus operator`);\n\t}\n}\n\n// return a transformed times operator\nfunction transformTimesOperator(node, opts) {\n\tif (isTimesOperator(node)) {\n\t\t// [ * ]\n\t\treturn node.value;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a times operator`);\n\t}\n}\n\n// return a transformed minus-plus-times operator\nfunction transformMinusPlusTimesOperator(node, opts) {\n\tif (isMinusPlusTimesOperator(node)) {\n\t\t// [ - | + | * ]\n\t\treturn node.value;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a plus, minus, or times operator`);\n\t}\n}\n\n/* Additional transforms\n/* ========================================================================== */\n\nfunction transformWord(node, opts) {\n\tif (isWord(node)) {\n\t\treturn node.value;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid word`);\n\t}\n}\n\nfunction transformNode(node) {\n\treturn Object(node);\n}\n\n/* Transform helper\n/* ========================================================================== */\n\n// return the first set of transformed arguments allowable by the parameters\nfunction transformArgsByParams(node, params) {\n\tconst nodes = (node.nodes || []).slice(1, -1);\n\tconst opts = { unresolved: 'ignore' };\n\n\treturn params.map(param => nodes.map(\n\t\t(childNode, index) => typeof param[index] === 'function' ? param[index](childNode, opts) : undefined\n\t).filter(child => typeof child !== 'boolean')).filter(param => param.every(\n\t\tresult => result !== undefined\n\t))[0] || [];\n}\n\n/* Walk helper (required because the default walker is affected by mutations)\n/* ========================================================================== */\n\n// run a function over each node and hen walk each child node of that node\nfunction walk(node, fn) {\n\tfn(node);\n\n\tif (Object(node.nodes).length) {\n\t\tnode.nodes.slice().forEach(childNode => {\n\t\t\twalk(childNode, fn);\n\t\t});\n\t}\n}\n\n/* Variable validators\n/* ========================================================================== */\n\n// return whether the node is a var function\nfunction isVariable(node) {\n\t// var()\n\treturn Object(node).type === 'func' && varMatch.test(node.value);\n}\n\n/* Adjustment validators\n/* ========================================================================== */\n\n// return whether the node is an a/alpha/blue/green/red adjuster\nfunction isAlphaBlueGreenRedAdjuster(node) {\n\t// [ a(), alpha(), blue(), green(), red() ]\n\treturn Object(node).type === 'func' && alphaBlueGreenRedMatch.test(node.value);\n}\n\n// return whether the node is an rgb adjuster\nfunction isRGBAdjuster(node) {\n\tre